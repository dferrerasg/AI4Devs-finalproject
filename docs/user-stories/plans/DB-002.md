# Plan de Implementación: [DB-002] Esquema Base de Datos: Proyectos y Miembros

**Estado:** Pendiente

Este documento detalla el plan para implementar las tablas y relaciones necesarias para la gestión de proyectos y miembros del equipo, correspondiente a la User Story US-002.

## Objetivos
- Definir el modelo `Project` para almacenar la información base de los proyectos.
- Definir el modelo `ProjectMember` para gestionar la colaboración y roles dentro de cada proyecto.
- Establecer las relaciones entre `User`, `Project` y `ProjectMember`.
- Generar la migración correspondiente en la base de datos.
- Actualizar el cliente de Prisma.

## Pasos de Implementación

### 1. Actualización de `schema.prisma`
Modificar el archivo `apps/backend/prisma/schema.prisma` para agregar los nuevos modelos y enumerados.

**Cambios propuestos:**

1.  **Nuevos Enums:**
    - `ProjectStatus`: ACTIVE, ARCHIVED.
    - `ProjectRole`: OWNER, EDITOR, VIEWER.

2.  **Modelo User (Actualización):**
    - Agregar campo de relación `projects` para los proyectos que el usuario posee (es arquitecto).
    - Agregar campo de relación `projectMemberships` para los proyectos donde participa como miembro.

3.  **Modelo Project:**
    - Campos estándar: `id`, `created_at`, `updated_at`.
    - Campos de negocio: `title`, `description` (opcional), `status`.
    - Relación con User (Arquitecto): `architect_id`.
    - Borrado lógico: `deleted_at`.
    - Relación con ProjectMember: `members`.

4.  **Modelo ProjectMember (Tabla Pivote):**
    - Relación con Project: `project_id`.
    - Relación con User: `user_id`.
    - Rol en el proyecto: `role`.
    - Fecha de unión: `joined_at`.
    - Clave compuesta o única para evitar duplicados `[projectId, userId]`.

**Código Prisma Propuesto:**

```prisma
// apps/backend/prisma/schema.prisma

// ... Enums existentes ...

enum ProjectStatus {
  ACTIVE
  ARCHIVED
}

enum ProjectRole {
  OWNER
  EDITOR
  VIEWER
}

model User {
  // ... campos existentes ...
  
  // Nuevas relaciones
  projects           Project[]       @relation("OwnerProjects")
  projectMemberships ProjectMember[]

  // @@map("users")
}

model Project {
  id          String        @id @default(uuid())
  title       String
  description String?
  architectId String        @map("architect_id")
  architect   User          @relation("OwnerProjects", fields: [architectId], references: [id])
  status      ProjectStatus @default(ACTIVE)
  deletedAt   DateTime?     @map("deleted_at")
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  members     ProjectMember[]

  @@map("projects")
}

model ProjectMember {
  id        String      @id @default(uuid())
  projectId String      @map("project_id")
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  userId    String      @map("user_id")
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      ProjectRole @default(VIEWER)
  joinedAt  DateTime    @default(now()) @map("joined_at")

  @@unique([projectId, userId])
  @@map("project_members")
}
```

### 2. Ejecución de Migración
Ejecutar el siguiente comando desde el directorio `apps/backend` para aplicar los cambios a la base de datos de desarrollo:

```bash
npx prisma migrate dev --name init_projects
```

Este comando:
1.  Generará el archivo SQL de migración en `prisma/migrations`.
2.  Aplicará los cambios en PostgreSQL.
3.  Regenerará el cliente de Prisma (`@prisma/client`).

### 3. Verificación
- **Base de Datos:** Verificar que las tablas `projects` y `project_members` han sido creadas con las columnas y claves foráneas correctas.
- **Cliente Prisma:** Verificar que se puede instanciar un objeto con los nuevos tipos (ej. verificar autocompletado en un archivo `.ts` temporal).
