import { prisma } from '../prisma';
import { IUserRepository } from '@/domain/repositories/user.repository';
import { User, UserRole, SubscriptionTier } from '@/domain/entities/user.entity';

export class PrismaUserRepository implements IUserRepository {
  async findByEmail(email: string): Promise<User | null> {
    const userModel = await prisma.user.findUnique({
      where: { email },
    });

    if (!userModel) return null;

    return new User(
      userModel.id,
      userModel.email,
      userModel.passwordHash,
      userModel.role as UserRole,
      userModel.subscriptionTier as SubscriptionTier,
      userModel.fullName,
      userModel.createdAt,
      userModel.updatedAt,
    );
  }

  async save(user: User): Promise<User> {
    // Determine if update or create based on ID existence? 
    // In Clean Arch, usually 'save' handles both, but here let's assume create for now 
    // or upsert. However, since ID is generated by DB usually or UUID, 
    // if we are passing a User entity that hasn't been persisted, 
    // we might need to separate create/update or handle inside.
    // simpler: usage of prisma.create usually.
    
    // For this context, let's assume we use it mainly for creation in Register
    // If user has ID, it might be update.
    // The entity 'User' has 'id'. If it's a new user, do we generate ID in domain or DB?
    // Prisma schema says @default(uuid()).
    
    // Let's implement 'create' logic essentially.
    
    const savedUser = await prisma.user.create({
      data: {
        email: user.email,
        passwordHash: user.passwordHash,
        fullName: user.fullName,
        role: user.role,
        subscriptionTier: user.subscriptionTier,
      },
    });

    return new User(
      savedUser.id,
      savedUser.email,
      savedUser.passwordHash,
      savedUser.role as UserRole,
      savedUser.subscriptionTier as SubscriptionTier,
      savedUser.fullName,
      savedUser.createdAt,
      savedUser.updatedAt,
    );
  }
}
